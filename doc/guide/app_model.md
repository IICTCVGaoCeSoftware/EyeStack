# 应用程序模型 {#guide-app_model}

> 本文写作日期：2022/3/29

本文描述了 Eyestack 设计用法的上层应用程序模型。

## 程序生命周期

![](life_cycle.png)

上图描述了 Eyestack 上层应用程序的生命周期，其中实线和实线框表示固定的流程和环节，虚线框表示可定制的环节，虚线表示可以插入环节或修改的流程。

```cpp
/**
 * @file main.cpp
 */

#include "main.hpp"

int
main(int argc, char* argv[])
{
  // A

  esf::Application app(argc, argv);

  // B

  auto retval = app.exec();

  // C

  return retval;
}

class MyClass {
  MyClass() {
    // D
  }
} gMyclass;
```

上层应用程序的开发重点关注图中可定制的部分，我以上面这个最简单的上层应用程序，来介绍 Eyestack 程序的生命周期：

1. 全局和静态变量初始化

   通过在上层应用中声明全局和静态变量等机制实现修改，例如注释 D 所在部分。不推荐这种做法，因为 C++ 中这些变量的初始化时机无法控制，除非十分有把握的情况，否则不应该使用这种机制。

2. 主函数到 Eyestack 初始化

   即注释 A 所在部分，此处代码在 Eyestack 初始化前执行。建议 Application 类越早构造越好，这里通常只进行一些 Eyestack 配置、命令行解析等操作。

3. Eyestack 初始化完成到 app.exec()

   即注释 B 所在部分，此处对框架进行定制和配置，通常是上层程序编写的主体部分。

4. app.exec() 到程序退出

   即注释 C 所在部分，建议在这里写一些其它资源的释放操作代码，如果没有代码需要编写，可以直接简写为 `return app.exec();`。

## 运行时刻结构

下图描述了设计上 Eyestack 上层应用程序的运行时刻结构，其中虚线代表设计中可变动修改的部分：

![](runtime.png)

1. 线程归属性

   线程归属性是来自于 Qt 框架的一个概念，表示对象只能从某个线程中操作，否则行为是未定义的，可能导致程序崩溃等后果。

   Eyestack 框架的主界面、配置管理器、工作控制器、日志系统都只能在主线程中操作，而通知管理器、后台任务控制则可以从任何线程中访问，即线程安全的。

2. 线程间通讯

   因为具有线程归属性的对象只能从特定线程中操作，所以当其它线程想要操作该对象时，它必须向拥有该对象的线程发送请求，这就引出了线程间通讯的问题。例如上图中，用户在主界面上修改了其它计算资源（例如修改一个参数），实质上在底层主线程只不过是向工作线程发送了一个修改请求，最终是由工作线程完成实际操作。

   Eyestack 框架基于 Qt 实现多线程，工作线程运行消息循环，所以可以通过 Qt 的跨线程信号实现线程间通讯，也可以直接通过底层的消息机制实现固定的点对点通讯。
