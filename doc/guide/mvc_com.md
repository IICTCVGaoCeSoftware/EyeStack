# 组件封装的 MVC 模式 {#guide-mvc_com}

基于 Eyestack 框架的上层应用程序是一个多线程系统，通常，算法的内核函数运行在工作线程中，操作界面运行在主线程中。在采用消息通讯模式实现组件时，由于对象的线程归属性，主线程中的组件界面对象不应该直接操作工作线程中的组件内核对象，因此很多上层组件都需要在主线程和工作线程之间通讯。如果你正苦于无法写出让界面和内核之间可靠工作的安全代码，本文将帮助你使用 MVC 模式解决这一问题。

> 如今 MVC 这个词的含义已经被大大泛化了，什么东西都能说自己是 MVC 模式，最要命的是还有一些名字差不多、但同样模糊的相似概念：MVP、MVVM 等。因此，有人看了下面的内容后会说：“这哪里是什么 MVC 模式，这不是 MVP 模式吗？”，为了避免纠结这种无聊问题，我在这里提前做出解答：你爱叫啥叫啥，理解文章中的做法就好。

使用这个模式的第一步是把一个组件的代码划分为 3 个部分，并且弄清楚每个部分都在哪里工作：

![](mvc.png)

我们以 OpenCV 的 VideoCapture 为例，解释各部分的含义：

1. M - 完全被动的内核对象

   在本例中，这部分就是 cv::VideoCapture 类的代码，它是 OpenCV 的开发人员编写的，它的代码里没有调用你写的函数和方法。而它也没有给你任何注册回调的接口，所以，VideoCapture 类的对象对外就体现为完全被动的。当它状态发生变化时（比如相机连接断开），VideoCapture 不会通知你的界面去更新，而会等你下次再从中读取图像时给你一个空的 cv::Mat，这时调用者才知道图像流已经结束了。

   此外，内核对象通常都不是线程安全的，尽管它们并没有继承 QObject 类，你还是应当假定它们拥有线程归属性，要么你就得用锁保证对象的线程安全。由于缺陷检测系统在运行时很少人工干预的特点，在大部分情况下主线程并不会去操作内核对象，绝大部分时间都是工作线程自己去加锁放锁，因此，在实现中往往会选择前一种方案。

2. C - 工作线程中的控制器

   本例中，这部分就是 Eyestack::Gencom::VideoCapture 包装类。

   前文提到内核对象一般具有完全被动和线程不安全的两个特点，因此，要想实现更新主线程中的对象和响应主线程对象发来的消息，必须要一个工作线程中的对象来做消息的中转，这个中转对象就是图中的 C（控制器）部分。

   M 不会主动通知外界，这一点是改变不了的，但我们可以令 C 封装所有对 M 的操作，在每次操作后检查操作成功与否的状态，然后在 C 中发射通知信号。该方法奏效的关键在于一定要封装掉所有对 M 的操作，如果绕开 C 直接操作 M，就可能出现 M 和 V 状态不一致的问题。

   除了控制 M，C 还可以用来监视工作对象的状态。使用直接连接方式连接工作对象上的生命周期信号，就可以让工作线程与主线程的同步。

3. V - 主线程中的视图对象

   本例中，这部份就是 Eyestack::Gencom::VideoCapture 下的 SubUi 和 Config 两个类。可见，并不是说每个部分都必须是一个类，实际上在本例中是两个类共同充当了 V 的部分。

   V 部分的作用就是在主线程中发出控制信号，接受并响应 C 在工作线程中发出的信号，理解这部分的关键是明白 V 向 C 发出的信号并不是一种“命令”，而是“请求”，如果采用异步的线程间通讯方式，那么请求何时被处理由工作线程何时空闲决定。

然后，就是各部分之间如何通讯，反映到代码上就是怎么写：

- M - C

  C 类单向调用 M 类上的方法，M 类不用知道 C 类的存在。

- C - V

  C、V 之间需要相互调用，并且调用要通过线程间通讯方式实现，可以使用信号机制，使得 C 类和 V 类无需知道彼此的存在，也可以使用 invokeMethod 实现一对一的跨线程通讯，由于组件通常作为一个整体使用，C 类与 V 类之间的耦合性比较强，因此建议用后者。

- V - M

  V、M 之间不应该有调用关系。

最后，注意这个模式仅适用于基于消息通讯的设计，消息通讯仅是达成目的的手段之一，不是唯一。在某些时候，使用共享内存模式是更好的选择，设计时需要灵活变通。
