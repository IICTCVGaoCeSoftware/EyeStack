# 如何提高代码的安全性 {#manual-safe_code}

本文总结了一些 Eyestack 框架编写时用于增强代码安全性的惯用写法。代码安全就是指代码是否可能产生意料之外的行为，本质上，这些意料之外情况产生的根本原因是在代码设计时欠缺考虑，因为设计时无法做到面面俱到，所以无法保证代码的绝对安全性。而在实践中，更多的情况是由于错误地使用底层接口而产生的，这时如果底层提供了一些机制防止误用，就可以促使上层写出正确的代码，进而增强上层程序的代码安全性。

## assert

assert 语句是最基本的防止代码被误用的机制，相比较于抛出异常，assert 让用户别无选择，他必须按照调用规范来写，否则就无法使用。常用 assert 机制可以避免代码中的错误发生扩散，从而方便错误的定位和修复。

Eyestack 框架使用 Q_ASSERT 而不是标准库的 assert 实现断言机制。

## 初始化检查

Eyestack 框架的许多模块都需要一次全局的初始化之后才能使用，这些全局的初始化函数通常被命名为模块命名空间下的 `ginit` 函数。

项目的许多模块中的代码都需要一些全局初始化操作后才能使用，包括 dll 的加载、全局变量的初始化、元类型的注册等。

为了检查某段代码在执行时是否已经完成初始化，Eyestack 在实现时提供了一个方便函数 `ginit_required()` 和一个方便类 `GInitRequried`。

前者用于在任意函数中进行检查，其内部使用 Q_ASSERT 检查全局初始化，用法如下：

```cpp
void foo() {
  ginit_required();

  // ...
}
```

后者用于给一个类整体添加检查，其原理是利用 C++ 的继承机制，在父类的构造函数中进行检查，使用时只需让类私有继承这个接口即可，例如：

```cpp
class Foo : GinitRequired
{
  // ...
};
```

## 借用语义与移交语义

借用与移交主要体现在指针上，由于指针申请后必须释放，且只能释放一次，这个释放操作的责任就是指针的所有权。

根据指针所有权在调用某个函数前后发生的变化，指针参数传递可分为借用语义和移交语义：

- 借用语义

  函数不负责释放指针，只是对指针指向的数据进行了操作。

- 移交语义

  被调用函数接管指针的释放责任，调用者不应该再释放指针。

在 Eyestack 框架的实现中，借用语义**通常**使用左值引用而非指针的形式传递，偶尔也有例外情况。
